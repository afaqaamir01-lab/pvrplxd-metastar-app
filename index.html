<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Access Restricted</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&display=swap" rel="stylesheet">

<style>
:root {
  --border: rgba(255, 255, 255, 0.1);
  --bg-card: rgba(10, 10, 10, 0.7);
  --bg-body: #050505;
  --accent: #FF4D4D;
}

* { box-sizing: border-box; }

body {
  margin: 0;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  background-color: var(--bg-body);
  font-family: 'Space Grotesk', sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  
  /* Clean Grid */
  background-image: 
    linear-gradient(rgba(255, 255, 255, 0.04) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
  background-size: 50px 50px;
}

/* Particle Container */
#particles {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 5;
  overflow: hidden;
}

.particle {
  position: absolute;
  background: var(--accent);
  border-radius: 50%;
  opacity: 0;
}

.card-container {
  position: relative;
  z-index: 10;
  width: auto;
  will-change: transform;
  transform-style: preserve-3d;
  perspective: 1200px; /* Deeper perspective for cooler 3D */
}

.card {
  position: relative;
  background: var(--bg-card);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--border);
  padding: 32px;
  border-radius: 24px;
  display: flex;
  align-items: center;
  gap: 24px;
  width: 500px;
  user-select: none;
  cursor: grab;
  overflow: hidden; /* Key for the glare effect */
  
  /* Initial Shadow */
  box-shadow: 
    0 20px 50px -10px rgba(0,0,0,0.6),
    0 0 0 1px rgba(255,255,255,0.05);
}

.card:active {
  cursor: grabbing;
}

/* Holographic Glare Layer */
.card-glare {
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(
    circle at center,
    rgba(255, 255, 255, 0.15) 0%,
    transparent 50%
  );
  opacity: 0;
  pointer-events: none;
  mix-blend-mode: overlay;
  transform: translate(0, 0);
  transition: opacity 0.3s ease;
}

.card:hover .card-glare,
.card:active .card-glare {
  opacity: 1;
}

.icon-box {
  width: 64px;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 77, 77, 0.1);
  border: 1px solid rgba(255, 77, 77, 0.2);
  border-radius: 16px;
  flex-shrink: 0;
  color: var(--accent);
  position: relative;
  z-index: 2;
}

.icon-box svg {
  width: 32px;
  height: 32px;
  stroke-width: 2;
}

.content {
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
  z-index: 2;
}

.title {
  color: #FFF;
  font-size: 1.25rem;
  font-weight: 700;
  margin: 0;
}

.description {
  color: #9CA3AF;
  font-size: 0.95rem;
  line-height: 1.5;
  margin: 0;
}

/* Status Indicator */
.status-badge {
  position: absolute;
  top: 16px;
  right: 16px;
  width: 6px;
  height: 6px;
  background: var(--accent);
  border-radius: 50%;
  box-shadow: 0 0 12px var(--accent);
  animation: pulse 2s infinite;
  z-index: 2;
}

@keyframes pulse {
  0% { opacity: 1; }
  50% { opacity: 0.4; }
  100% { opacity: 1; }
}

@media (max-width: 600px) {
  .card {
    width: 85vw;
    flex-direction: column;
    text-align: center;
    padding: 30px 24px;
  }
}
</style>
</head>
<body>

<div id="particles"></div>

<div class="card-container" id="draggable-card">
  <div class="card">
    <div class="card-glare"></div>
    <div class="status-badge"></div>
    
    <div class="icon-box">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
        <path d="M8 11h8"></path>
        <path d="M12 15V7"></path>
      </svg>
    </div>

    <div class="content">
      <h2 class="title">Access Restricted</h2>
      <p class="description">
        Security node locked. Throw the card to break the physics engine.
      </p>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Draggable.min.js"></script>

<script>
  gsap.registerPlugin(Draggable);

  const container = document.getElementById("draggable-card");
  const card = container.querySelector('.card');
  const glare = card.querySelector('.card-glare');
  const particleContainer = document.getElementById("particles");

  // Intro
  gsap.from(container, { y: 100, opacity: 0, duration: 1, ease: "power4.out" });

  // --- 1. PARTICLE SYSTEM ---
  function spawnParticle(x, y, velX, velY) {
    if (Math.abs(velX) < 100 && Math.abs(velY) < 100) return; // Only spawn if moving fast

    const p = document.createElement("div");
    p.classList.add("particle");
    particleContainer.appendChild(p);
    
    // Random size between 2px and 4px
    const size = Math.random() * 3 + 1;
    
    gsap.set(p, {
      x: x,
      y: y,
      width: size,
      height: size,
      opacity: 0.8
    });

    // Animate particle shooting backwards
    gsap.to(p, {
      x: x - (velX * 0.1) + (Math.random() * 20 - 10), // Opposite to movement
      y: y - (velY * 0.1) + (Math.random() * 20 - 10),
      opacity: 0,
      duration: 0.6,
      ease: "power2.out",
      onComplete: () => p.remove()
    });
  }

  // --- 2. PHYSICS ENGINE ---
  Draggable.create(container, {
    type: "x,y",
    bounds: window,
    edgeResistance: 0.5,
    inertia: true,
    
    onPress: function() {
      gsap.to(card, { scale: 0.97, duration: 0.1 });
      gsap.killTweensOf(container); // Catch it mid-air
    },

    onDrag: function(e) {
      const vX = this.getVelocity("x");
      const vY = this.getVelocity("y");
      
      // A. Dynamic Glare (Follows mouse)
      // Calculate mouse position relative to card center
      const cardRect = card.getBoundingClientRect();
      const relX = (this.pointerX - cardRect.left) - (cardRect.width / 2);
      const relY = (this.pointerY - cardRect.top) - (cardRect.height / 2);
      
      gsap.to(glare, {
        x: relX * 1.5,
        y: relY * 1.5,
        duration: 0.1
      });

      // B. 3D Tilt & Squash/Stretch
      // Clamp rotation
      const rotY = gsap.utils.clamp(-15, 15, vX / 80);
      const rotX = gsap.utils.clamp(-15, 15, -vY / 80);
      
      // Squash/Stretch logic (Cartoon physics)
      // Moving Horizontal? Stretch width, shrink height
      const stretch = Math.min(Math.abs(vX) / 3000, 0.1); 
      
      gsap.to(card, {
        rotationY: rotY,
        rotationX: rotX,
        scaleX: 1 + stretch,
        scaleY: 1 - stretch,
        duration: 0.3,
        ease: "power2.out"
      });

      // C. Spawn Particles at cursor position
      spawnParticle(this.pointerX, this.pointerY, vX, vY);
    },

    onDragEnd: function() {
      const vX = this.getVelocity("x");
      const vY = this.getVelocity("y");

      // --- MANUAL INERTIA CALCULATION ---
      // This mimics the "Throw" effect
      
      // 1. Friction factor (higher = slides less)
      const friction = 0.9;
      
      // 2. Calculate target based on velocity
      // We multiply velocity to project where it lands
      let targetX = this.x + (vX * 0.4);
      let targetY = this.y + (vY * 0.4);
      
      // 3. Wall Bounce Logic
      // Check boundaries manually
      const bounds = container.getBoundingClientRect();
      const parentW = window.innerWidth;
      const parentH = window.innerHeight;
      
      // Calculate min/max translations
      const minX = this.minX; 
      const maxX = this.maxX; 
      const minY = this.minY; 
      const maxY = this.maxY;

      let bounce = false;

      // If target exceeds bounds, bounce it back slightly
      if (targetX > maxX) { targetX = maxX - 50; bounce = true; }
      if (targetX < minX) { targetX = minX + 50; bounce = true; }
      if (targetY > maxY) { targetY = maxY - 50; bounce = true; }
      if (targetY < minY) { targetY = minY + 50; bounce = true; }

      // 4. Determine Ease
      // If we hit a wall, use "back.out" to simulate a bounce
      // If we slide freely, use "power4.out" for smooth friction
      const easeType = bounce ? "back.out(1.2)" : "power4.out";
      
      // 5. Calculate Duration based on distance
      const dist = Math.abs(targetX - this.x) + Math.abs(targetY - this.y);
      const dur = Math.min(dist / 500, 1.2); // Cap at 1.2s

      // EXECUTE THROW
      gsap.to(container, {
        x: targetX,
        y: targetY,
        duration: Math.max(dur, 0.6), // Min duration 0.6s
        ease: easeType,
        onUpdate: () => {
           // Keep updating tilt as it slides
           const currentVX = gsap.getProperty(container, "x") - (this._prevX || 0);
           this._prevX = gsap.getProperty(container, "x");
           
           gsap.to(card, {
             rotationY: currentVX * 3, // Tilt
             rotationX: 0,
             scaleX: 1, // Return to normal shape
             scaleY: 1,
             duration: 0.2
           });
        },
        onComplete: () => {
          // Reset to perfect stillness
          gsap.to(card, {
            rotationY: 0,
            rotationX: 0,
            scale: 1,
            duration: 0.5,
            ease: "elastic.out(1, 0.5)"
          });
        }
      });
    }
  });
  
  // Resize Fix
  window.addEventListener("resize", () => Draggable.get(container).applyBounds(window));

</script>

</body>
</html>
